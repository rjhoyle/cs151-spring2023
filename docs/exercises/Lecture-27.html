<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Lecture 27 | Your awesome title</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Lecture 27" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<meta property="og:description" content="Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description." />
<link rel="canonical" href="http://localhost:4000/exercises/Lecture-27.html" />
<meta property="og:url" content="http://localhost:4000/exercises/Lecture-27.html" />
<meta property="og:site_name" content="Your awesome title" />
<script type="application/ld+json">
{"headline":"Lecture 27","description":"Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.","@type":"WebPage","url":"http://localhost:4000/exercises/Lecture-27.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" /></head>
<body><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1 id="lecture-27--apr-17th-2020">Lecture 27 – Apr 17th, 2020</h1>

<h2 id="setup">Setup</h2>
<ol>
  <li>Log in to clyde.</li>
</ol>

<h2 id="task">Task</h2>
<ol>
  <li>
    <p><a href="Lecture-26.html">Last time</a>, you wrote two versions of a program to
compute a 1-byte checksum. If you completed them, you may use those
programs. Otherwise, you can copy <code class="language-plaintext highlighter-rouge">~steve/ex/checksum-v2</code> to your home
directory and use my solutions.</p>

    <p>If you use your own, edit the <code class="language-plaintext highlighter-rouge">Makefile</code> to change
<code class="language-plaintext highlighter-rouge">-fsanitize=address,undefined</code> to <code class="language-plaintext highlighter-rouge">-fsanitize=undefined</code> in both the <code class="language-plaintext highlighter-rouge">CFLAGS</code>
and <code class="language-plaintext highlighter-rouge">LDFLAGS</code>. Run <code class="language-plaintext highlighter-rouge">$ make clean</code> and then <code class="language-plaintext highlighter-rouge">$ make</code> to rebuild without the
Address Sanitizer.</p>
  </li>
  <li>You can time how long a Bash command takes to run but prefixing the command
with <code class="language-plaintext highlighter-rouge">time</code>. Time how long <code class="language-plaintext highlighter-rouge">checksum</code> and <code class="language-plaintext highlighter-rouge">checksum2</code> take to run on
themselves:
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ time ./checksum checksum checksum2
$ time ./checksum2 checksum checksum2
</code></pre></div>    </div>
    <p>Time will print out three numbers, the total (<code class="language-plaintext highlighter-rouge">real</code>) time it took
to run the command and how much of that was spent in your code (<code class="language-plaintext highlighter-rouge">user</code>)
versus the kernel (<code class="language-plaintext highlighter-rouge">sys</code>).</p>

    <p>You probably saw that <code class="language-plaintext highlighter-rouge">checksum</code> spent significantly more time in the
kernel than <code class="language-plaintext highlighter-rouge">checksum2</code>.</p>

    <p>Let’s figure out why that is.</p>
  </li>
  <li>You’re going to use <code class="language-plaintext highlighter-rouge">strace(1)</code> to trace the system calls made by a
program. We’re interested in file operations since that’s what the
difference between the two programs are. We can use the <code class="language-plaintext highlighter-rouge">-e</code> option to
limit the set of system calls <code class="language-plaintext highlighter-rouge">strace(1)</code> prints out. To make things
shorter, let’s run the checksum programs on the <code class="language-plaintext highlighter-rouge">Makefile</code>.
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ strace -e trace=open,openat,close,read,write ./checksum Makefile
$ strace -e trace=open,openat,close,read,write ./checksum2 Makefile
</code></pre></div>    </div>

    <p>In both cases, it will open, read from, and close files you don’t care
about. You can ignore those lines of output and just focus on the ones
where it’s opening and reading from the <code class="language-plaintext highlighter-rouge">Makefile</code>. I.e., focus on the
lines starting with</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>openat(AT_FDCWD, "Makefile", O_RDONLY)  = 3
</code></pre></div>    </div>
    <p>(<code class="language-plaintext highlighter-rouge">openat(2)</code> is a system call like <code class="language-plaintext highlighter-rouge">open(2)</code> except it takes the path to be
relative to a directory. You can read about its operation in its man page,
if you like.)</p>

    <p>Why did <code class="language-plaintext highlighter-rouge">checksum</code> take so much more time than <code class="language-plaintext highlighter-rouge">checksum2</code>? Next time you
find yourself writing code to read and write from files, think carefully
about whether you want to use a <code class="language-plaintext highlighter-rouge">FILE *</code> or a file descriptor.</p>
  </li>
  <li>
    <p>In Bash, we can redirect output of an arbitrary command to a file like this
<code class="language-plaintext highlighter-rouge">$ cmd &gt;output.txt</code>.</p>

    <p>Let’s figure out how Bash does that using <code class="language-plaintext highlighter-rouge">strace(1)</code>. Bash’s <code class="language-plaintext highlighter-rouge">-c</code> option
takes a string to run as input. E.g., if we run</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ bash -c '/bin/echo hello &gt;output.txt'
</code></pre></div>    </div>
    <p>in Bash, then this will start a new instance of Bash which will run the
command in quotes and then exit.</p>

    <p>We can use strace’s <code class="language-plaintext highlighter-rouge">-f</code> option to trace children processes (remember, Bash
will first <code class="language-plaintext highlighter-rouge">fork(2)</code> and then use <code class="language-plaintext highlighter-rouge">execve(2)</code> to transform the child
process into <code class="language-plaintext highlighter-rouge">/bin/echo</code>.</p>

    <p>Run this command.</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ strace -o syscalls.txt -f bash -c '/bin/echo hello &gt;output.txt'
</code></pre></div>    </div>
    <p>Passing <code class="language-plaintext highlighter-rouge">-o file</code> to <code class="language-plaintext highlighter-rouge">strace(1)</code> causes it to write its output to <code class="language-plaintext highlighter-rouge">file</code>
rather than <code class="language-plaintext highlighter-rouge">stderr</code>.</p>
  </li>
  <li>
    <p>Open <code class="language-plaintext highlighter-rouge">syscalls.txt</code> in an editor (Vim will highlight the <code class="language-plaintext highlighter-rouge">strace(1)</code> output
by default. There’s an Emacs mode that will do it too, but it doesn’t
appear to be installed on Clyde.) There’s a lot of output here. The number
preceding each line is the process id (PID) of the process that made the
system call.</p>

    <p>Let’s find the <code class="language-plaintext highlighter-rouge">fork(2)</code> in the output. Interestingly, Linux doesn’t use a
<code class="language-plaintext highlighter-rouge">fork</code> system call. Instead, it uses <code class="language-plaintext highlighter-rouge">clone</code> which is more general. When I
did this, I got the line</p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>8038  clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f76f75c2a10) = 8039
</code></pre></div>    </div>
    <p>which tells me that the Bash with PID 8038 forked and the child had
PID 8039. The next few lines of <code class="language-plaintext highlighter-rouge">rt_sig...</code> system calls are changing
signal handling masks, we’ll talk about this next time.</p>

    <p>There’s also a <code class="language-plaintext highlighter-rouge">getpid(2)</code> and <code class="language-plaintext highlighter-rouge">wait4(2)</code>. The latter is just like
<code class="language-plaintext highlighter-rouge">wait(2)</code> but with more options.</p>

    <p>Finally, there’s an <code class="language-plaintext highlighter-rouge">openat(2)</code> which opens <code class="language-plaintext highlighter-rouge">output.txt</code> for writing,
creating it if it doesn’t already exist, and truncating the file if it
does.</p>

    <p>Starting with the <code class="language-plaintext highlighter-rouge">openat(2)</code> and going up to the system call just before
the <code class="language-plaintext highlighter-rouge">execve("/bin/echo", ...)</code> is the sequence of system calls that Bash
made to perform the redirection. There’s only one new one there. Read its
corresponding man page.</p>
  </li>
  <li>Copy <code class="language-plaintext highlighter-rouge">~steve/ex/redir</code> to your directory. Modify <code class="language-plaintext highlighter-rouge">redir.c</code> such that when
you run <code class="language-plaintext highlighter-rouge">$ ./redir -o file command arguments</code> it runs <code class="language-plaintext highlighter-rouge">command arguments</code>
with <code class="language-plaintext highlighter-rouge">stdout</code> redirected to <code class="language-plaintext highlighter-rouge">file</code>. You only need to add some lines inside
the <code class="language-plaintext highlighter-rouge">if</code> statement to open the file and perform the redirection. You can
make a similar set of system calls that Bash did to perform the
redirection.</li>
</ol>

      </div>
    </main></body>

</html>
